import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {minimatch} from 'minimatch';
import {CodePackerConfig, DirectoryConfig} from './config';
import {debugLog} from './utils';

export async function packCode(config: CodePackerConfig): Promise<Map<string, string> | null> {
  debugLog('Starting packCode function');
  debugLog('Config:', JSON.stringify(config, null, 2));

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    vscode.window.showErrorMessage('No workspace folder found');
    return null;
  }

  const results = new Map<string, string>();

  for (const dirConfig of config.directories) {
    try {
      const result = await packDirectory(workspaceFolder, dirConfig);
      if (result) {
        results.set(dirConfig.outputFile, result);
      }
    } catch (error) {
      console.error(`Error packing directory ${dirConfig.sourceDirectory}:`, error);
      vscode.window.showErrorMessage(`Failed to pack directory ${dirConfig.sourceDirectory}: ${error}`);
    }
  }

  if (results.size > 0) {
    vscode.window.showInformationMessage(
      `Code packed successfully. ${results.size} file(s) created.`,
      'Open Files'
    ).then(selection => {
      if (selection === 'Open Files') {
        for (const [outputFile] of results) {
          const outputPath = path.join(workspaceFolder.uri.fsPath, outputFile);
          vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(outputPath));
        }
      }
    });
    return results;
  }

  return null;
}

async function packDirectory(
  workspaceFolder: vscode.WorkspaceFolder,
  dirConfig: DirectoryConfig
): Promise<string | null> {
  const sourceDir = path.resolve(workspaceFolder.uri.fsPath, dirConfig.sourceDirectory);
  debugLog('Resolved source directory:', sourceDir);

  const outputPath = path.join(workspaceFolder.uri.fsPath, dirConfig.outputFile);
  debugLog('Output file path:', outputPath);

  // Delete the existing output file if it exists
  if (fs.existsSync(outputPath)) {
    try {
      await fs.promises.unlink(outputPath);
      debugLog(`Existing output file deleted: ${outputPath}`);
    } catch (error) {
      console.error(`Error deleting existing output file: ${error}`);
      vscode.window.showErrorMessage(`Failed to delete existing output file: ${outputPath}`);
      return null;
    }
  }

  let output = '';
  output += "--- START OF HEADER ---\n";
  output += `Generated on: ${new Date().toISOString()}\n`;
  output += "Generated by: VS Code Code Packer Extension\n";
  output += "Purpose: Code packing for analysis or documentation\n";
  output += `Source Directory: ${dirConfig.sourceDirectory}\n`;
  output += "--- END OF HEADER ---\n\n";

  try {
    const recursiveExclusionPatterns = dirConfig.exclusionPatterns.map((pattern: string) => {
      if (pattern.includes('/') || pattern.includes('\\')) {
        return pattern.endsWith('/') || pattern.endsWith('\\') ? `${pattern}**` : `${pattern}/**`;
      } else if (pattern.includes('*')) {
        return `**/${pattern}`;
      } else {
        return `**/${pattern}`;
      }
    });

    const allFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(sourceDir, '**'),
      new vscode.RelativePattern(sourceDir, `{${recursiveExclusionPatterns.join(',')}}`)
    );

    debugLog(`Total files found: ${allFiles.length}`);

    const files = allFiles.filter(file => {
      const relativePath = path.relative(sourceDir, file.fsPath).replace(/\\/g, '/');
      debugLog(`Checking file: ${relativePath}`);

      const shouldInclude = dirConfig.inclusionPatterns.length === 0 ||
        dirConfig.inclusionPatterns.some((pattern: string) => {
          const match = minimatch(relativePath, pattern, {matchBase: true});
          debugLog(`  Inclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
          return match;
        });

      const shouldExclude = recursiveExclusionPatterns.some((pattern: string) => {
        const match = minimatch(relativePath, pattern, {matchBase: true});
        debugLog(`  Exclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
        return match;
      });

      return shouldInclude && !shouldExclude;
    });

    let includedCount = 0;
    let excludedCount = 0;

    for (const file of files) {
      const absoluteFilePath = file.fsPath;
      const relativePath = path.relative(sourceDir, absoluteFilePath).replace(/\\/g, '/');

      try {
        const content = await fs.promises.readFile(absoluteFilePath, 'utf8');
        output += `--- FILE: ${relativePath} ---\n`;
        output += content;
        output += "\n--- END FILE ---\n\n";
        includedCount++;
      } catch (err) {
        console.error(`Error reading file ${absoluteFilePath}:`, err);
        vscode.window.showWarningMessage(`Failed to read file: ${relativePath}`);
        excludedCount++;
      }
    }

    debugLog(`Directory ${dirConfig.sourceDirectory}: Total files: ${files.length}, Included: ${includedCount}, Excluded: ${excludedCount}`);

    await fs.promises.writeFile(outputPath, output, 'utf8');
    debugLog('File written successfully:', outputPath);

    return output;
  } catch (err) {
    console.error('Error packing directory:', err);
    let errorMessage = 'An unknown error occurred while packing code.';
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }
    vscode.window.showErrorMessage(`Failed to pack directory ${dirConfig.sourceDirectory}: ${errorMessage}`);
    return null;
  }
}
