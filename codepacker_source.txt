--- START OF HEADER ---
Generated on: 2024-11-13T18:02:43.902Z
Generated by: VS Code Code Packer Extension
Purpose: Code packing for analysis or documentation
Source Directory: .
--- END OF HEADER ---

--- FILE: CHANGELOG.md ---
# Change Log

All notable changes to the "codepacker" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## 1.2.0

- Removed default configuration settings in favor of explicit user configuration
- Status bar item now shows immediately upon extension activation
- Improved configuration UI with better validation and clearer prompts

## 1.1.0

- Added support for multiple directory configurations
- Each directory can now have its own output file and patterns
- Updated UI to manage multiple directory configurations
- Maintained backward compatibility with single-directory config

## 1.0.2

- Fixed issue with recursive named-file exclusion.

## 1.0.1

- Fixed issue with recursive directory exclusion.

## 1.0.0

- Initial release

--- END FILE ---

--- FILE: LICENSE.md ---
# MIT License

Copyright (c) 2024 [Your Name or Organization]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END FILE ---

--- FILE: package.json ---
{
  "name": "codepacker",
  "displayName": "Code Packer",
  "description": "Pack project code files into text files for easy sharing with LLMs",
  "version": "1.1.0",
  "icon": "images/codepacker-icon.png",
  "publisher": "JustinSchneider",
  "engines": {
    "vscode": "^1.90.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": ["*"],
  "main": "./dist/extension.js",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/JustinSchneider/CodePacker.git"
  },
  "contributes": {
    "commands": [
      {
        "command": "extension.packCode",
        "title": "Code Packer: Pack Code",
        "category": "Code Packer"
      },
      {
        "command": "extension.configureCodePacker",
        "title": "Code Packer: Configure Settings",
        "category": "Code Packer"
      },
      {
        "command": "extension.generateDiff",
        "title": "Code Packer: Generate Git Diff",
        "category": "Code Packer"
      }
    ],
    "views": {
      "explorer": [
        {
          "id": "codePackerExplorer",
          "name": "Code Packer"
        }
      ]
    },
    "configuration": {
      "title": "Code Packer",
      "properties": {
        "codePacker.debug": {
          "type": "boolean",
          "default": false,
          "description": "Enable debug mode for Code Packer"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "npm run check-types && npm run lint && node esbuild.js",
    "watch": "npm-run-all -p watch:*",
    "watch:esbuild": "node esbuild.js --watch",
    "watch:tsc": "tsc --noEmit --watch --project tsconfig.json",
    "prelaunch": "npm run compile",
    "package": "npm run check-types && npm run lint && node esbuild.js --production",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "check-types": "tsc --noEmit",
    "lint": "eslint src --ext ts",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/minimatch": "^5.1.2",
    "@types/mocha": "^10.0.7",
    "@types/node": "^20.14.9",
    "@types/vscode": "^1.90.0",
    "@typescript-eslint/eslint-plugin": "^7.14.1",
    "@typescript-eslint/parser": "^7.11.0",
    "@vscode/test-cli": "^0.0.9",
    "@vscode/test-electron": "^2.4.0",
    "esbuild": "^0.21.5",
    "eslint": "^8.57.0",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.4.5"
  },
  "dependencies": {
    "minimatch": "^9.0.5"
  }
}
--- END FILE ---

--- FILE: esbuild.js ---
const esbuild = require("esbuild");

const production = process.argv.includes('--production');
const watch = process.argv.includes('--watch');

/**
 * @type {import('esbuild').Plugin}
 */
const esbuildProblemMatcherPlugin = {
	name: 'esbuild-problem-matcher',

	setup(build) {
		build.onStart(() => {
			console.log('[watch] build started');
		});
		build.onEnd((result) => {
			result.errors.forEach(({ text, location }) => {
				console.error(`✘ [ERROR] ${text}`);
				console.error(`    ${location.file}:${location.line}:${location.column}:`);
			});
			console.log('[watch] build finished');
		});
	},
};

async function main() {
	const ctx = await esbuild.context({
		entryPoints: [
			'src/extension.ts'
		],
		bundle: true,
		format: 'cjs',
		minify: production,
		sourcemap: !production,
		sourcesContent: false,
		platform: 'node',
		outfile: 'dist/extension.js',
		external: ['vscode'],
		logLevel: 'silent',
		plugins: [
			/* add to the end of plugins array */
			esbuildProblemMatcherPlugin,
		],
	});
	if (watch) {
		await ctx.watch();
	} else {
		await ctx.rebuild();
		await ctx.dispose();
	}
}

main().catch(e => {
	console.error(e);
	process.exit(1);
});

--- END FILE ---

--- FILE: .vscode/extensions.json ---
{
  // See http://go.microsoft.com/fwlink/?LinkId=827846
  // for the documentation about the extensions.json format
  "recommendations": ["dbaeumer.vscode-eslint", "connor4312.esbuild-problem-matchers", "ms-vscode.extension-test-runner"]
}

--- END FILE ---

--- FILE: .vscode/settings.json ---
// Place your settings in this file to overwrite default and user settings.
{
    "files.exclude": {
        "out": false, // set this to true to hide the "out" folder with the compiled JS files
        "dist": false // set this to true to hide the "dist" folder with the compiled JS files
    },
    "search.exclude": {
        "out": true, // set this to false to include "out" folder in search results
        "dist": true // set this to false to include "dist" folder in search results
    },
    // Turn off tsc task auto detection since we have the necessary tasks as npm scripts
    "typescript.tsc.autoDetect": "off"
}
--- END FILE ---

--- FILE: .vscode/launch.json ---
// A launch configuration that compiles the extension and then opens it inside a new window
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
{
	"version": "0.2.0",
	"configurations": [
		{
			"name": "Run Extension",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}"
			],
			"outFiles": [
				"${workspaceFolder}/dist/**/*.js"
			],
			"preLaunchTask": "npm: watch"
		},
		{
			"name": "Extension Tests",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}",
				"--extensionTestsPath=${workspaceFolder}/out/test/suite/index"
			],
			"outFiles": [
				"${workspaceFolder}/out/**/*.js"
			],
			"preLaunchTask": "npm: pretest"
		}
	],
	"compounds": [
		{
			"name": "Watch and Run Extension",
			"configurations": [
				"Run Extension"
			],
			"preLaunchTask": "npm: watch"
		}
	]
}
--- END FILE ---

--- FILE: .vscode/code-packer.json ---
{
  "directories": [
    {
      "sourceDirectory": ".",
      "outputFile": "codepacker_source.txt",
      "exclusionPatterns": [
        "node_modules",
        "dist",
        "images",
        "out",
        ".vscode-test",
        "*.vsix",
        "package-lock.json"
      ],
      "inclusionPatterns": [
        "*.ts",
        "*.md",
        "*.json",
        "*.js"
      ]
    }
  ],
  "debug": false
}
--- END FILE ---

--- FILE: vsc-extension-quickstart.md ---
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesn’t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Setup

* install the recommended extensions (amodio.tsl-problem-matcher, ms-vscode.extension-test-runner, and dbaeumer.vscode-eslint)


## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.


## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).

--- END FILE ---

--- FILE: tsconfig.json ---
{
	"compilerOptions": {
		"module": "Node16",
		"target": "ES2022",
		"outDir": "dist",
		"lib": [
			"ES2022"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true /* enable all strict type-checking options */
		/* Additional Checks */
		// "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
		// "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
		// "noUnusedParameters": true,  /* Report errors on unused parameters. */
	},
	"exclude": [
		"node_modules",
		".vscode-test"
	]
}
--- END FILE ---

--- FILE: README.md ---
# Code Packer

<p align="center">
  <img src="./images/codepacker-icon.png" alt="Code Packer Logo" width="128"/>
</p>

Code Packer is a Visual Studio Code extension that allows you to easily pack your project's code files and git diffs into text files. This makes it simple to share specific parts of your project with LLMs, ensuring accurate context while keeping the file sizes manageable.

## Features

- Pack multiple code directories into separate text files
- Generate diffs between git branches for easy sharing
- Configure different patterns and outputs for each directory
- Customizable source directories, output files, and file patterns
- Exclude specific files or directories from packing
- Include only specific file types in the packed output
- Easy-to-use interface with status bar buttons and explorer view
- Project-specific configuration options
- Debug mode for troubleshooting

### Pack Code

Quickly pack your code using the status bar button or command palette. You can pack all configured directories at once, creating separate output files for each.

### Generate Branch Diffs

Create text files containing diffs between any two git branches in your repository:

1. Click the "Generate Diff" button in the status bar or use the command palette
2. Select your source and target branches from the dropdown menus
3. Choose a name for your output file
4. The diff will be generated with helpful metadata and saved to your specified file

### Configure Settings

Easily configure your packing settings through the extension's UI. Add, edit, or remove directory configurations as needed.

### Explorer View

View and manage your Code Packer configurations in the VS Code explorer. Each directory configuration shows its source, output, and patterns.

## Requirements

- Visual Studio Code version 1.90.0 or higher
- Git extension must be enabled for diff generation feature

## Configuration

You can create a project-specific configuration file `.vscode/code-packer.json` with the following structure:

```json
{
  "directories": [
    {
      "sourceDirectory": "src/frontend",
      "outputFile": "frontend_code.txt",
      "exclusionPatterns": ["node_modules", "dist", "*.test.ts"],
      "inclusionPatterns": ["*.ts", "*.tsx", "*.css", "*.json"]
    },
    {
      "sourceDirectory": "src/backend",
      "outputFile": "backend_code.txt",
      "exclusionPatterns": ["node_modules", "dist", "*.test.ts"],
      "inclusionPatterns": ["*.ts", "*.js", "*.json"]
    }
  ],
  "debug": false
}
```

Alternatively, you can use the built-in configuration UI to manage your settings.

## Commands

All commands can be accessed through the Command Palette (Ctrl+Shift+P / Cmd+Shift+P) under the "Code Packer" category:

- `Code Packer: Pack Code` - Pack your code according to current configuration
- `Code Packer: Generate Branch Diff` - Create a diff between two git branches
- `Code Packer: Configure Settings` - Open the configuration UI

These commands are also available through buttons in the status bar for quick access.

## Known Issues

Currently, there are no known issues. If you encounter any problems, please report them on our [GitHub issues page](https://github.com/JustinSchneider/CodePacker/issues).

## Release Notes

See the [Change Log](CHANGELOG.md) for the full version history and list of changes.

## Contributing

If you'd like to contribute to the development of Code Packer, please visit our [GitHub repository](https://github.com/JustinSchneider/CodePacker).

## License

This extension is licensed under the [MIT License](LICENSE.md).

--- END FILE ---

--- FILE: .vscode/tasks.json ---
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "watch",
            "dependsOn": [
                "npm: watch:tsc",
                "npm: watch:esbuild"
            ],
            "presentation": {
                "reveal": "never"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "type": "npm",
            "script": "watch:esbuild",
            "group": "build",
            "problemMatcher": [
                {
                    "owner": "esbuild",
                    "pattern": [
                        {
                            "regexp": "^✘\\s+\\[ERROR\\]\\s+(.*)$",
                            "message": 1
                        },
                        {
                            "regexp": "^\\s+(.*):(\\d+):(\\d+):$",
                            "file": 1,
                            "line": 2,
                            "column": 3
                        }
                    ],
                    "background": {
                        "activeOnStart": true,
                        "beginsPattern": "^\\[watch\\] build started",
                        "endsPattern": "^\\[watch\\] build finished"
                    }
                }
            ],
            "isBackground": true,
            "label": "npm: watch:esbuild",
            "presentation": {
                "group": "watch",
                "reveal": "never"
            }
        },
        {
            "type": "npm",
            "script": "watch:tsc",
            "group": "build",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "label": "npm: watch:tsc",
            "presentation": {
                "group": "watch",
                "reveal": "never"
            }
        },
        {
            "type": "npm",
            "script": "watch-tests",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "presentation": {
                "reveal": "never",
                "group": "watchers"
            },
            "group": "build"
        },
        {
            "label": "tasks: watch-tests",
            "dependsOn": [
                "npm: watch",
                "npm: watch-tests"
            ],
            "problemMatcher": []
        }
    ]
}
--- END FILE ---

--- FILE: src/utils.ts ---
import * as vscode from 'vscode';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let isDebugMode = false;

export function initializeDebugLogging() {
  outputChannel = vscode.window.createOutputChannel('Code Packer');
  updateDebugMode();
}

export function updateDebugMode() {
  const config = vscode.workspace.getConfiguration('codePacker');
  isDebugMode = config.get<boolean>('debug', false);
  debugLog(`Debug mode ${isDebugMode ? 'enabled' : 'disabled'}`);
}

export function setDebugMode(debug: boolean) {
  isDebugMode = debug;
}

export function debugLog(...args: any[]) {
  if (isDebugMode) {
    const message = args.map(arg =>
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ');

    if (outputChannel) {
      outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
    }
    console.log(`[Code Packer Debug] ${message}`);
  }
}

export function getSafeProjectName(workspaceFolder: vscode.WorkspaceFolder): string {
  const projectName = path.basename(workspaceFolder.uri.fsPath);
  return projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

--- END FILE ---

--- FILE: src/uiComponents.ts ---
import * as vscode from 'vscode';
import { loadConfig } from './config';

export class CodePackerTreeDataProvider implements vscode.TreeDataProvider<ConfigTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<ConfigTreeItem | undefined | null | void> = new vscode.EventEmitter<ConfigTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<ConfigTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: ConfigTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: ConfigTreeItem): Promise<ConfigTreeItem[]> {
    if (!element) {
      const config = loadConfig();
      if (!config) {
        return [];
      }

      const items: ConfigTreeItem[] = [];
      
      // Add debug status
      items.push(new ConfigTreeItem(
        `Debug Mode: ${config.debug ? 'Enabled' : 'Disabled'}`,
        vscode.TreeItemCollapsibleState.None
      ));

      // Add directory configurations
      for (let i = 0; i < config.directories.length; i++) {
        const dir = config.directories[i];
        items.push(new ConfigTreeItem(
          `Directory Configuration ${i + 1}`,
          vscode.TreeItemCollapsibleState.Expanded,
          {
            sourceDirectory: dir.sourceDirectory,
            outputFile: dir.outputFile,
            exclusionPatterns: dir.exclusionPatterns,
            inclusionPatterns: dir.inclusionPatterns
          }
        ));
      }

      return items;
    } else if (element.dirConfig) {
      const dir = element.dirConfig;
      return [
        new ConfigTreeItem(`Source: ${dir.sourceDirectory}`, vscode.TreeItemCollapsibleState.None),
        new ConfigTreeItem(`Output: ${dir.outputFile}`, vscode.TreeItemCollapsibleState.None),
        new ConfigTreeItem(`Exclusions: ${dir.exclusionPatterns.join(', ')}`, vscode.TreeItemCollapsibleState.None),
        new ConfigTreeItem(`Inclusions: ${dir.inclusionPatterns.join(', ')}`, vscode.TreeItemCollapsibleState.None)
      ];
    }

    return [];
  }
}

class ConfigTreeItem extends vscode.TreeItem {
  constructor(
    public readonly label: string,
    public readonly collapsibleState: vscode.TreeItemCollapsibleState,
    public readonly dirConfig?: {
      sourceDirectory: string;
      outputFile: string;
      exclusionPatterns: string[];
      inclusionPatterns: string[];
    }
  ) {
    super(label, collapsibleState);
  }
}
--- END FILE ---

--- FILE: src/test/extension.test.ts ---
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});

--- END FILE ---

--- FILE: src/gitOperations.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { debugLog } from './utils';

export interface DiffConfig {
  sourceBranch: string;
  targetBranch: string;
  outputFile: string;
}

export async function generateDiff(config: DiffConfig): Promise<string | null> {
  const gitExtension = vscode.extensions.getExtension('vscode.git');
  if (!gitExtension) {
    vscode.window.showErrorMessage('Git extension is not available');
    return null;
  }

  const git = gitExtension.exports.getAPI(1);
  const repository = git.repositories[0];
  
  if (!repository) {
    vscode.window.showErrorMessage('No Git repository found in the current workspace');
    return null;
  }

  try {
    // Get the diff using git show command instead of diffBetween
    
    const diff = await repository.diffBetween(config.sourceBranch, config.targetBranch);
    if (!diff) {
      vscode.window.showInformationMessage('No differences found between the branches');
      return null;
    }

    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
        throw new Error('No workspace folder found');
    }

    const outputPath = path.join(workspaceFolder.uri.fsPath, config.outputFile);
    
    // Create the diff file content with metadata
    let output = "--- START OF HEADER ---\n";
    output += `Generated on: ${new Date().toISOString()}\n`;
    output += "Generated by: VS Code Code Packer Extension\n";
    output += "Purpose: Git branch diff for analysis\n";
    output += `Source Branch: ${config.sourceBranch}\n`;
    output += `Target Branch: ${config.targetBranch}\n`;
    output += "--- END OF HEADER ---\n\n";
    output += diff;  // diff should already be a string now

    // Write the diff to the output file
    await fs.promises.writeFile(outputPath, output, 'utf8');
    debugLog('Diff file written successfully:', outputPath);

    return output;
  } catch (error) {
    console.error('Error generating diff:', error);
    vscode.window.showErrorMessage(`Failed to generate diff: ${error}`);
    return null;
  }
}

export async function getBranches(): Promise<string[]> {
    const gitExtension = vscode.extensions.getExtension('vscode.git');
    if (!gitExtension) {
        throw new Error('Git extension is not available');
    }

    const git = gitExtension.exports.getAPI(1);
    const repository = git.repositories[0];
    
    if (!repository) {
        throw new Error('No Git repository found in the current workspace');
    }

    // Get all branches including remote ones
    const branches = await repository.getBranches();
    return branches.map((branch: {name: any;}) => branch.name);
}

export async function promptForDiffConfig(): Promise<DiffConfig | null> {
    try {
        const branches = await getBranches();
        
        // Get source branch
        const sourceBranch = await vscode.window.showQuickPick(branches, {
            placeHolder: 'Select source branch',
            title: 'Select Source Branch'
        });
        
        if (!sourceBranch) {
            return null;
        }

        // Get target branch
        const targetBranch = await vscode.window.showQuickPick(
            branches.filter(b => b !== sourceBranch),
            {
                placeHolder: 'Select target branch',
                title: 'Select Target Branch'
            }
        );
        
        if (!targetBranch) {
            return null;
        }

        // Get output file name
        const defaultFileName = `diff_${sourceBranch.replace(/[^a-z0-9]/gi, '_')}_${targetBranch.replace(/[^a-z0-9]/gi, '_')}.txt`;
        const outputFile = await vscode.window.showInputBox({
            prompt: 'Enter output file name',
            value: defaultFileName,
            validateInput: input => {
                if (!input.trim()) {
                    return 'Output file name cannot be empty';
                }
                return null;
            }
        });

        if (!outputFile) {
            return null;
        }

        return {
            sourceBranch,
            targetBranch,
            outputFile
        };
    } catch (error) {
        vscode.window.showErrorMessage(`Error configuring diff: ${error}`);
        return null;
    }
}

--- END FILE ---

--- FILE: src/fileOperations.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {minimatch} from 'minimatch';
import {CodePackerConfig, DirectoryConfig} from './config';
import {debugLog} from './utils';

export async function packCode(config: CodePackerConfig): Promise<Map<string, string> | null> {
  debugLog('Starting packCode function');
  debugLog('Config:', JSON.stringify(config, null, 2));

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    vscode.window.showErrorMessage('No workspace folder found');
    return null;
  }

  const results = new Map<string, string>();

  for (const dirConfig of config.directories) {
    try {
      const result = await packDirectory(workspaceFolder, dirConfig);
      if (result) {
        results.set(dirConfig.outputFile, result);
      }
    } catch (error) {
      console.error(`Error packing directory ${dirConfig.sourceDirectory}:`, error);
      vscode.window.showErrorMessage(`Failed to pack directory ${dirConfig.sourceDirectory}: ${error}`);
    }
  }

  if (results.size > 0) {
    vscode.window.showInformationMessage(
      `Code packed successfully. ${results.size} file(s) created.`,
      'Open Files'
    ).then(selection => {
      if (selection === 'Open Files') {
        for (const [outputFile] of results) {
          const outputPath = path.join(workspaceFolder.uri.fsPath, outputFile);
          vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(outputPath));
        }
      }
    });
    return results;
  }

  return null;
}

async function packDirectory(
  workspaceFolder: vscode.WorkspaceFolder,
  dirConfig: DirectoryConfig
): Promise<string | null> {
  const sourceDir = path.resolve(workspaceFolder.uri.fsPath, dirConfig.sourceDirectory);
  debugLog('Resolved source directory:', sourceDir);

  const outputPath = path.join(workspaceFolder.uri.fsPath, dirConfig.outputFile);
  debugLog('Output file path:', outputPath);

  // Delete the existing output file if it exists
  if (fs.existsSync(outputPath)) {
    try {
      await fs.promises.unlink(outputPath);
      debugLog(`Existing output file deleted: ${outputPath}`);
    } catch (error) {
      console.error(`Error deleting existing output file: ${error}`);
      vscode.window.showErrorMessage(`Failed to delete existing output file: ${outputPath}`);
      return null;
    }
  }

  let output = '';
  output += "--- START OF HEADER ---\n";
  output += `Generated on: ${new Date().toISOString()}\n`;
  output += "Generated by: VS Code Code Packer Extension\n";
  output += "Purpose: Code packing for analysis or documentation\n";
  output += `Source Directory: ${dirConfig.sourceDirectory}\n`;
  output += "--- END OF HEADER ---\n\n";

  try {
    const recursiveExclusionPatterns = dirConfig.exclusionPatterns.map((pattern: string) => {
      if (pattern.includes('/') || pattern.includes('\\')) {
        return pattern.endsWith('/') || pattern.endsWith('\\') ? `${pattern}**` : `${pattern}/**`;
      } else if (pattern.includes('*')) {
        return `**/${pattern}`;
      } else {
        return `**/${pattern}`;
      }
    });

    const allFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(sourceDir, '**'),
      new vscode.RelativePattern(sourceDir, `{${recursiveExclusionPatterns.join(',')}}`)
    );

    debugLog(`Total files found: ${allFiles.length}`);

    const files = allFiles.filter(file => {
      const relativePath = path.relative(sourceDir, file.fsPath).replace(/\\/g, '/');
      debugLog(`Checking file: ${relativePath}`);

      const shouldInclude = dirConfig.inclusionPatterns.length === 0 ||
        dirConfig.inclusionPatterns.some((pattern: string) => {
          const match = minimatch(relativePath, pattern, {matchBase: true});
          debugLog(`  Inclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
          return match;
        });

      const shouldExclude = recursiveExclusionPatterns.some((pattern: string) => {
        const match = minimatch(relativePath, pattern, {matchBase: true});
        debugLog(`  Exclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
        return match;
      });

      return shouldInclude && !shouldExclude;
    });

    let includedCount = 0;
    let excludedCount = 0;

    for (const file of files) {
      const absoluteFilePath = file.fsPath;
      const relativePath = path.relative(sourceDir, absoluteFilePath).replace(/\\/g, '/');

      try {
        const content = await fs.promises.readFile(absoluteFilePath, 'utf8');
        output += `--- FILE: ${relativePath} ---\n`;
        output += content;
        output += "\n--- END FILE ---\n\n";
        includedCount++;
      } catch (err) {
        console.error(`Error reading file ${absoluteFilePath}:`, err);
        vscode.window.showWarningMessage(`Failed to read file: ${relativePath}`);
        excludedCount++;
      }
    }

    debugLog(`Directory ${dirConfig.sourceDirectory}: Total files: ${files.length}, Included: ${includedCount}, Excluded: ${excludedCount}`);

    await fs.promises.writeFile(outputPath, output, 'utf8');
    debugLog('File written successfully:', outputPath);

    return output;
  } catch (err) {
    console.error('Error packing directory:', err);
    let errorMessage = 'An unknown error occurred while packing code.';
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }
    vscode.window.showErrorMessage(`Failed to pack directory ${dirConfig.sourceDirectory}: ${errorMessage}`);
    return null;
  }
}

--- END FILE ---

--- FILE: src/extension.ts ---
import * as vscode from 'vscode';
import {loadConfig, configureCodePacker} from './config';
import {packCode} from './fileOperations';
import {generateDiff, promptForDiffConfig} from './gitOperations';
import {CodePackerTreeDataProvider} from './uiComponents';
import {debugLog, initializeDebugLogging, updateDebugMode} from './utils';

let packCodeStatusBarItem: vscode.StatusBarItem;
let generateDiffStatusBarItem: vscode.StatusBarItem;

function createStatusBarItems(context: vscode.ExtensionContext) {
	// Pack Code button
	packCodeStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
	packCodeStatusBarItem.text = "$(package) Pack Code";
	packCodeStatusBarItem.command = 'extension.packCode';
	packCodeStatusBarItem.tooltip = "Pack your code files into a single text file";
	packCodeStatusBarItem.show();
	context.subscriptions.push(packCodeStatusBarItem);

	// Generate Diff button
	generateDiffStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 99);
	generateDiffStatusBarItem.text = "$(git-compare) Generate Diff";
	generateDiffStatusBarItem.command = 'extension.generateDiff';
	generateDiffStatusBarItem.tooltip = "Generate a diff between two branches";
	generateDiffStatusBarItem.show();
	context.subscriptions.push(generateDiffStatusBarItem);
}

export async function activate(context: vscode.ExtensionContext) {
    // Initialize logging first
    initializeDebugLogging();
    debugLog('Activating extension');

    // Create and show status bar item immediately
    createStatusBarItems(context);

    // Set up tree view
    const treeDataProvider = new CodePackerTreeDataProvider();
    vscode.window.createTreeView('codePackerExplorer', {treeDataProvider});

    // Register the pack code command
    context.subscriptions.push(
        vscode.commands.registerCommand('extension.packCode', async () => {
            try {
                const config = await loadConfig();
                if (!config) {
                    const response = await vscode.window.showErrorMessage(
                        'No configuration found. Would you like to configure Code Packer now?',
                        'Yes', 'No'
                    );
                    if (response === 'Yes') {
                        await configureCodePacker();
                        // Retry packing after configuration
                        const newConfig = await loadConfig();
                        if (newConfig) {
                            await packCode(newConfig);
                        }
                    }
                    return;
                }
                await packCode(config);
                treeDataProvider.refresh();
            } catch (error) {
                vscode.window.showErrorMessage(`Error during code packing: ${error}`);
            }
        })
		);
	
		// Register the generate diff command
		context.subscriptions.push(
			vscode.commands.registerCommand('extension.generateDiff', async () => {
					try {
							const config = await promptForDiffConfig();
							if (config) {
									const diff = await generateDiff(config);
									if (diff) {
										vscode.window.showInformationMessage(
												`Diff generated successfully: ${config.outputFile}`,
												'Open in Explorer'
										).then(selection => {
												if (selection === 'Open in Explorer') {
														const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
														if (workspaceFolder) {
																const outputPath = vscode.Uri.file(
																		vscode.Uri.joinPath(workspaceFolder.uri, config.outputFile).fsPath
																);
																vscode.commands.executeCommand('revealFileInOS', outputPath);
														}
												}
										});
								}
							}
					} catch (error) {
							vscode.window.showErrorMessage(`Error generating diff: ${error}`);
					}
			})
		);

    // Register the configure command
    context.subscriptions.push(
        vscode.commands.registerCommand('extension.configureCodePacker', async () => {
            try {
                await configureCodePacker();
                treeDataProvider.refresh();
            } catch (error) {
                vscode.window.showErrorMessage(`Error during configuration: ${error}`);
            }
        })
    );

    // Watch for configuration changes
    context.subscriptions.push(
        vscode.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('codePacker.debug')) {
                updateDebugMode();
            }
        })
    );

    debugLog('Extension activated');
}

export function deactivate() {
	if (packCodeStatusBarItem) {
			packCodeStatusBarItem.dispose();
	}
	if (generateDiffStatusBarItem) {
			generateDiffStatusBarItem.dispose();
	}
}
--- END FILE ---

--- FILE: src/config.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {debugLog, setDebugMode} from './utils';

export interface DirectoryConfig {
  sourceDirectory: string;
  outputFile: string;
  exclusionPatterns: string[];
  inclusionPatterns: string[];
}

export interface CodePackerConfig {
  directories: DirectoryConfig[];
  debug: boolean;
}

export function loadConfig(): CodePackerConfig | null {
  debugLog('Loading configuration');

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    return null;
  }

  const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'code-packer.json');
  debugLog('Attempting to load config from:', configPath);

  if (fs.existsSync(configPath)) {
    try {
      const configContent = fs.readFileSync(configPath, 'utf8');
      const rawConfig = JSON.parse(configContent);
      
      // Handle backward compatibility with old config format
      if ('sourceDirectory' in rawConfig) {
        // Convert old format to new format
        const config: CodePackerConfig = {
          directories: [{
            sourceDirectory: rawConfig.sourceDirectory,
            outputFile: rawConfig.outputFile,
            exclusionPatterns: rawConfig.exclusionPatterns,
            inclusionPatterns: rawConfig.inclusionPatterns
          }],
          debug: rawConfig.debug || false
        };
        setDebugMode(config.debug);
        debugLog('Converted old config format:', config);
        return config;
      }

      // New format
      setDebugMode(rawConfig.debug || false);
      debugLog('Loaded config:', rawConfig);
      return rawConfig;
    } catch (error) {
      console.error('[Code Packer] Error reading config file:', error);
      return null;
    }
  }
  
  return null; // Return null if no config exists instead of creating defaults
}

export async function configureCodePacker(): Promise<CodePackerConfig | null> {
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    vscode.window.showErrorMessage('No workspace folder found. Please open a folder before configuring Code Packer.');
    return null;
  }

  debugLog('Workspace folder:', workspaceFolder.uri.fsPath);
  const currentConfig = loadConfig();
  
  // Start with an empty config if none exists
  const config: CodePackerConfig = currentConfig || {
    directories: [],
    debug: false
  };

  while (true) {
    const action = await vscode.window.showQuickPick([
      'Add New Directory',
      ...(config.directories.length > 0 ? ['Edit Directory', 'Remove Directory'] : []),
      'Toggle Debug Mode',
      'Save Configuration',
      'Cancel'
    ], {
      placeHolder: 'Choose an action'
    });

    if (!action || action === 'Cancel') {
      return null;
    }

    if (action === 'Save Configuration') {
      if (config.directories.length === 0) {
        const response = await vscode.window.showWarningMessage(
          'No directories configured. Would you like to add one now?',
          'Yes', 'No'
        );
        if (response === 'Yes') {
          continue;
        } else {
          return null;
        }
      }
      break;
    }

    if (action === 'Toggle Debug Mode') {
      config.debug = !config.debug;
      continue;
    }

    if (action === 'Add New Directory') {
      const dirConfig = await configureDirectoryConfig();
      if (dirConfig) {
        config.directories.push(dirConfig);
      }
    } else if (action === 'Edit Directory') {
      const dirIndex = await selectDirectory(config.directories);
      if (dirIndex !== undefined) {
        const updatedConfig = await configureDirectoryConfig(config.directories[dirIndex]);
        if (updatedConfig) {
          config.directories[dirIndex] = updatedConfig;
        }
      }
    } else if (action === 'Remove Directory') {
      const dirIndex = await selectDirectory(config.directories);
      if (dirIndex !== undefined) {
        config.directories.splice(dirIndex, 1);
      }
    }
  }

  const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'code-packer.json');
  try {
    fs.mkdirSync(path.dirname(configPath), { recursive: true });
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    debugLog('Config file written successfully');
    vscode.window.showInformationMessage('Code Packer configuration saved successfully.');
  } catch (error) {
    console.error('Error writing config file:', error);
    vscode.window.showErrorMessage(`Failed to save Code Packer configuration: ${error}`);
    return null;
  }

  return config;
}

async function configureDirectoryConfig(existing?: DirectoryConfig): Promise<DirectoryConfig | null> {
  const sourceDirectory = await vscode.window.showInputBox({
    prompt: 'Enter source directory (relative to workspace root)',
    value: existing?.sourceDirectory || '',
    placeHolder: 'src',
    validateInput: input => {
      if (!input.trim()) {
        return 'Source directory cannot be empty';
      }
      if (input.includes('..')) {
        return 'Path cannot contain ".."';
      }
      return null;
    }
  });
  
  if (!sourceDirectory) {return null;}

  const outputFile = await vscode.window.showInputBox({
    prompt: 'Enter output file name',
    value: existing?.outputFile || '',
    placeHolder: 'packed/project_source.txt',
    validateInput: input => {
      if (!input.trim()) {
        return 'Output file name cannot be empty';
      }
      return null;
    }
  });
  
  if (!outputFile) {return null;}

  const exclusions = await vscode.window.showInputBox({
    prompt: 'Enter exclusion patterns (comma-separated)',
    value: existing?.exclusionPatterns.join(', ') || '',
    placeHolder: 'node_modules, dist, *.test.ts, *.meta'
  });
  
  if (exclusions === undefined) {return null;}

  const inclusions = await vscode.window.showInputBox({
    prompt: 'Enter inclusion patterns (comma-separated)',
    value: existing?.inclusionPatterns.join(', ') || '',
    placeHolder: '*.cs, *.ts, *.json'
  });
  
  if (inclusions === undefined) {return null;}

  return {
    sourceDirectory,
    outputFile,
    exclusionPatterns: exclusions.split(',').map(p => p.trim()).filter(p => p !== ''),
    inclusionPatterns: inclusions.split(',').map(p => p.trim()).filter(p => p !== '')
  };
}

async function selectDirectory(directories: DirectoryConfig[]): Promise<number | undefined> {
  const items = directories.map((dir, index) => ({
    label: `${index + 1}. ${dir.sourceDirectory}`,
    description: `Output: ${dir.outputFile}`,
    index
  }));

  const selected = await vscode.window.showQuickPick(items, {
    placeHolder: 'Select a directory configuration'
  });

  return selected?.index;
}
--- END FILE ---

