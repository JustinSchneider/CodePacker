--- START OF HEADER ---
Generated on: 2024-11-06T16:32:11.157Z
Generated by: VS Code Code Packer Extension
Purpose: Code packing for analysis or documentation
Source Directory: .
--- END OF HEADER ---

--- FILE: CHANGELOG.md ---
# Change Log

All notable changes to the "codepacker" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## 1.1.0

- Added support for multiple directory configurations
- Each directory can now have its own output file and patterns
- Updated UI to manage multiple directory configurations
- Maintained backward compatibility with single-directory config

## 1.0.2

- Fixed issue with recursive named-file exclusion.

## 1.0.1

- Fixed issue with recursive directory exclusion.

## 1.0.0

- Initial release

--- END FILE ---

--- FILE: esbuild.js ---
const esbuild = require("esbuild");

const production = process.argv.includes('--production');
const watch = process.argv.includes('--watch');

/**
 * @type {import('esbuild').Plugin}
 */
const esbuildProblemMatcherPlugin = {
	name: 'esbuild-problem-matcher',

	setup(build) {
		build.onStart(() => {
			console.log('[watch] build started');
		});
		build.onEnd((result) => {
			result.errors.forEach(({ text, location }) => {
				console.error(`✘ [ERROR] ${text}`);
				console.error(`    ${location.file}:${location.line}:${location.column}:`);
			});
			console.log('[watch] build finished');
		});
	},
};

async function main() {
	const ctx = await esbuild.context({
		entryPoints: [
			'src/extension.ts'
		],
		bundle: true,
		format: 'cjs',
		minify: production,
		sourcemap: !production,
		sourcesContent: false,
		platform: 'node',
		outfile: 'dist/extension.js',
		external: ['vscode'],
		logLevel: 'silent',
		plugins: [
			/* add to the end of plugins array */
			esbuildProblemMatcherPlugin,
		],
	});
	if (watch) {
		await ctx.watch();
	} else {
		await ctx.rebuild();
		await ctx.dispose();
	}
}

main().catch(e => {
	console.error(e);
	process.exit(1);
});

--- END FILE ---

--- FILE: LICENSE.md ---
# MIT License

Copyright (c) 2024 [Your Name or Organization]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END FILE ---

--- FILE: .vscode/code-packer.json ---
{
  "directories": [
    {
      "sourceDirectory": ".",
      "outputFile": "codepacker_source.txt",
      "exclusionPatterns": [
        "node_modules",
        "dist",
        "images",
        "out",
        ".vscode-test",
        "*.vsix",
        "package-lock.json"
      ],
      "inclusionPatterns": [
        "*.ts",
        "*.md",
        "*.json",
        "*.js"
      ]
    }
  ],
  "debug": false
}
--- END FILE ---

--- FILE: .vscode/extensions.json ---
{
  // See http://go.microsoft.com/fwlink/?LinkId=827846
  // for the documentation about the extensions.json format
  "recommendations": ["dbaeumer.vscode-eslint", "connor4312.esbuild-problem-matchers", "ms-vscode.extension-test-runner"]
}

--- END FILE ---

--- FILE: .vscode/tasks.json ---
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "watch",
            "dependsOn": [
                "npm: watch:tsc",
                "npm: watch:esbuild"
            ],
            "presentation": {
                "reveal": "never"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "type": "npm",
            "script": "watch:esbuild",
            "group": "build",
            "problemMatcher": [
                {
                    "owner": "esbuild",
                    "pattern": [
                        {
                            "regexp": "^✘\\s+\\[ERROR\\]\\s+(.*)$",
                            "message": 1
                        },
                        {
                            "regexp": "^\\s+(.*):(\\d+):(\\d+):$",
                            "file": 1,
                            "line": 2,
                            "column": 3
                        }
                    ],
                    "background": {
                        "activeOnStart": true,
                        "beginsPattern": "^\\[watch\\] build started",
                        "endsPattern": "^\\[watch\\] build finished"
                    }
                }
            ],
            "isBackground": true,
            "label": "npm: watch:esbuild",
            "presentation": {
                "group": "watch",
                "reveal": "never"
            }
        },
        {
            "type": "npm",
            "script": "watch:tsc",
            "group": "build",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "label": "npm: watch:tsc",
            "presentation": {
                "group": "watch",
                "reveal": "never"
            }
        },
        {
            "type": "npm",
            "script": "watch-tests",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "presentation": {
                "reveal": "never",
                "group": "watchers"
            },
            "group": "build"
        },
        {
            "label": "tasks: watch-tests",
            "dependsOn": [
                "npm: watch",
                "npm: watch-tests"
            ],
            "problemMatcher": []
        }
    ]
}
--- END FILE ---

--- FILE: .vscode/settings.json ---
// Place your settings in this file to overwrite default and user settings.
{
    "files.exclude": {
        "out": false, // set this to true to hide the "out" folder with the compiled JS files
        "dist": false // set this to true to hide the "dist" folder with the compiled JS files
    },
    "search.exclude": {
        "out": true, // set this to false to include "out" folder in search results
        "dist": true // set this to false to include "dist" folder in search results
    },
    // Turn off tsc task auto detection since we have the necessary tasks as npm scripts
    "typescript.tsc.autoDetect": "off"
}
--- END FILE ---

--- FILE: vsc-extension-quickstart.md ---
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesn’t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Setup

* install the recommended extensions (amodio.tsl-problem-matcher, ms-vscode.extension-test-runner, and dbaeumer.vscode-eslint)


## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.


## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).

--- END FILE ---

--- FILE: .vscode/launch.json ---
// A launch configuration that compiles the extension and then opens it inside a new window
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
{
	"version": "0.2.0",
	"configurations": [
		{
			"name": "Run Extension",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}"
			],
			"outFiles": [
				"${workspaceFolder}/dist/**/*.js"
			],
			"preLaunchTask": "npm: watch"
		},
		{
			"name": "Extension Tests",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}",
				"--extensionTestsPath=${workspaceFolder}/out/test/suite/index"
			],
			"outFiles": [
				"${workspaceFolder}/out/**/*.js"
			],
			"preLaunchTask": "npm: pretest"
		}
	],
	"compounds": [
		{
			"name": "Watch and Run Extension",
			"configurations": [
				"Run Extension"
			],
			"preLaunchTask": "npm: watch"
		}
	]
}
--- END FILE ---

--- FILE: tsconfig.json ---
{
	"compilerOptions": {
		"module": "Node16",
		"target": "ES2022",
		"outDir": "dist",
		"lib": [
			"ES2022"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true /* enable all strict type-checking options */
		/* Additional Checks */
		// "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
		// "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
		// "noUnusedParameters": true,  /* Report errors on unused parameters. */
	},
	"exclude": [
		"node_modules",
		".vscode-test"
	]
}
--- END FILE ---

--- FILE: README.md ---
# Code Packer

<p align="center">
  <img src="./images/codepacker-icon.png" alt="Code Packer Logo" width="128"/>
</p>

Code Packer is a Visual Studio Code extension that allows you to easily pack your project's code files into text files. This makes it simple to share specific parts of your project with LLMs, ensuring accurate context while keeping the file sizes manageable.

## Features

- Pack multiple code directories into separate text files
- Configure different patterns and outputs for each directory
- Customizable source directories, output files, and file patterns
- Exclude specific files or directories from packing
- Include only specific file types in the packed output
- Easy-to-use interface with status bar button and explorer view
- Project-specific and global configuration options
- Debug mode for troubleshooting

### Pack Code

Quickly pack your code using the status bar button or command palette. You can pack all configured directories at once, creating separate output files for each.

### Configure Settings

Easily configure your packing settings through the extension's UI. Add, edit, or remove directory configurations as needed.

### Explorer View

View and manage your Code Packer configurations in the VS Code explorer. Each directory configuration shows its source, output, and patterns.

## Requirements

This extension requires Visual Studio Code version 1.90.0 or higher.

## Extension Settings

This extension contributes the following settings:

- `codePacker.debug`: Enable or disable debug mode for Code Packer.
- `codePacker.defaultSourceDirectory`: Set the default source directory for new configurations (relative to workspace root).
- `codePacker.defaultOutputFile`: Set the default output file name for new configurations.
- `codePacker.defaultExclusionPatterns`: Set default patterns for files to exclude from packing.
- `codePacker.defaultInclusionPatterns`: Set default patterns for files to include in packing.

You can configure these settings globally in your VS Code settings, or per-project in the `.vscode/settings.json` file.

Additionally, you can create a project-specific configuration file `.vscode/code-packer.json` with the following structure:

```json
{
  "directories": [
    {
      "sourceDirectory": "src/frontend",
      "outputFile": "frontend_code.txt",
      "exclusionPatterns": ["node_modules", "dist", "*.test.ts"],
      "inclusionPatterns": ["*.ts", "*.tsx", "*.css", "*.json"]
    },
    {
      "sourceDirectory": "src/backend",
      "outputFile": "backend_code.txt",
      "exclusionPatterns": ["node_modules", "dist", "*.test.ts"],
      "inclusionPatterns": ["*.ts", "*.js", "*.json"]
    }
  ],
  "debug": false
}
```

## How to Use

1. Install the Code Packer extension from the VS Code Marketplace.
2. Open a project in VS Code.
3. Click the "Pack Code" button in the status bar or run the "Pack Code" command from the command palette.
4. If it's your first time using the extension in the project, you'll be prompted to configure your settings.
5. Add one or more directory configurations through the configuration UI:
   - Choose "Configure Code Packer" from the command palette
   - Use "Add New Directory" to create additional configurations
   - Set the source directory, output file, and patterns for each
6. The extension will pack your code according to your settings and save it to the specified output files.
7. You can view and modify your current configurations in the Code Packer explorer view.

## Known Issues

Currently, there are no known issues. If you encounter any problems, please report them on our [GitHub issues page](https://github.com/JustinSchneider/CodePacker/issues).

## Release Notes

### 1.1.0

- Added support for multiple directory configurations
- Each directory can now have its own output file and patterns
- Updated UI to manage multiple directory configurations
- Maintained backward compatibility with single-directory config

### 1.0.2

- Fixed issue with recursive named-file exclusion.

### 1.0.1

- Fixed issue with recursive directory exclusion.

### 1.0.0

- Initial release

---

## Contributing

If you'd like to contribute to the development of Code Packer, please visit our [GitHub repository](https://github.com/JustinSchneider/CodePacker).

## License

This extension is licensed under the [MIT License](LICENSE.md).

--- END FILE ---

--- FILE: package.json ---
{
  "name": "codepacker",
  "displayName": "Code Packer",
  "description": "Pack project code files into text files for easy sharing with LLMs",
  "version": "1.1.0",
  "icon": "images/codepacker-icon.png",
  "publisher": "JustinSchneider",
  "engines": {
    "vscode": "^1.90.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [],
  "main": "./dist/extension.js",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/JustinSchneider/CodePacker.git"
  },
  "contributes": {
    "commands": [
      {
        "command": "extension.packCode",
        "title": "Pack Code"
      },
      {
        "command": "extension.configureCodePacker",
        "title": "Configure Code Packer"
      }
    ],
    "views": {
      "explorer": [
        {
          "id": "codePackerExplorer",
          "name": "Code Packer"
        }
      ]
    },
    "configuration": {
      "title": "Code Packer",
      "properties": {
        "codePacker.debug": {
          "type": "boolean",
          "default": false,
          "description": "Enable debug mode for Code Packer"
        },
        "codePacker.defaultSourceDirectory": {
          "type": "string",
          "default": ".",
          "description": "Default source directory for new configurations"
        },
        "codePacker.defaultOutputFile": {
          "type": "string",
          "default": "packed_code.txt",
          "description": "Default output file name for new configurations"
        },
        "codePacker.defaultExclusionPatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            "node_modules",
            "package-lock.json",
            ".git",
            "build",
            "dist",
            "out",
            "*.log",
            "*.lock",
            ".vscode"
          ],
          "description": "Default patterns for files to exclude from packing in new configurations"
        },
        "codePacker.defaultInclusionPatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            "*.cs",
            "*.ts",
            "*.js",
            "*.json",
            "*.md",
            "*.html",
            "*.css",
            "*.scss"
          ],
          "description": "Default patterns for files to include in packing in new configurations"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "npm run check-types && npm run lint && node esbuild.js",
    "watch": "npm-run-all -p watch:*",
    "watch:esbuild": "node esbuild.js --watch",
    "watch:tsc": "tsc --noEmit --watch --project tsconfig.json",
    "prelaunch": "npm run compile",
    "package": "npm run check-types && npm run lint && node esbuild.js --production",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "check-types": "tsc --noEmit",
    "lint": "eslint src --ext ts",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/minimatch": "^5.1.2",
    "@types/mocha": "^10.0.7",
    "@types/node": "^20.14.9",
    "@types/vscode": "^1.90.0",
    "@typescript-eslint/eslint-plugin": "^7.14.1",
    "@typescript-eslint/parser": "^7.11.0",
    "@vscode/test-cli": "^0.0.9",
    "@vscode/test-electron": "^2.4.0",
    "esbuild": "^0.21.5",
    "eslint": "^8.57.0",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.4.5"
  },
  "dependencies": {
    "minimatch": "^9.0.5"
  }
}
--- END FILE ---

--- FILE: src/utils.ts ---
import * as vscode from 'vscode';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let isDebugMode = false;

export function initializeDebugLogging() {
  outputChannel = vscode.window.createOutputChannel('Code Packer');
  updateDebugMode();
}

export function updateDebugMode() {
  const config = vscode.workspace.getConfiguration('codePacker');
  isDebugMode = config.get<boolean>('debug', false);
  debugLog(`Debug mode ${isDebugMode ? 'enabled' : 'disabled'}`);
}

export function setDebugMode(debug: boolean) {
  isDebugMode = debug;
}

export function debugLog(...args: any[]) {
  if (isDebugMode) {
    const message = args.map(arg =>
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ');

    if (outputChannel) {
      outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
    }
    console.log(`[Code Packer Debug] ${message}`);
  }
}

export function getSafeProjectName(workspaceFolder: vscode.WorkspaceFolder): string {
  const projectName = path.basename(workspaceFolder.uri.fsPath);
  return projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

export function getDefaultExclusionPatterns(): string[] {
  return [
    'node_modules',
    '.git',
    'build',
    'dist',
    'out',
    '*.log',
    '*.lock',
    '*.vsix',
    '.vscode'
  ];
}

export function getDefaultInclusionPatterns(): string[] {
  return [
    '*.ts',
    '*.js',
    '*.json',
    '*.md',
    '*.txt',
    '*.html',
    '*.css',
    '*.scss'
  ];
}
--- END FILE ---

--- FILE: src/uiComponents.ts ---
import * as vscode from 'vscode';
import { loadConfig } from './config';

export class CodePackerTreeDataProvider implements vscode.TreeDataProvider<ConfigTreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<ConfigTreeItem | undefined | null | void> = new vscode.EventEmitter<ConfigTreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<ConfigTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: ConfigTreeItem): vscode.TreeItem {
    return element;
  }

  async getChildren(element?: ConfigTreeItem): Promise<ConfigTreeItem[]> {
    if (!element) {
      const config = loadConfig();
      if (!config) {
        return [];
      }

      const items: ConfigTreeItem[] = [];
      
      // Add debug status
      items.push(new ConfigTreeItem(
        `Debug Mode: ${config.debug ? 'Enabled' : 'Disabled'}`,
        vscode.TreeItemCollapsibleState.None
      ));

      // Add directory configurations
      for (let i = 0; i < config.directories.length; i++) {
        const dir = config.directories[i];
        items.push(new ConfigTreeItem(
          `Directory Configuration ${i + 1}`,
          vscode.TreeItemCollapsibleState.Expanded,
          {
            sourceDirectory: dir.sourceDirectory,
            outputFile: dir.outputFile,
            exclusionPatterns: dir.exclusionPatterns,
            inclusionPatterns: dir.inclusionPatterns
          }
        ));
      }

      return items;
    } else if (element.dirConfig) {
      const dir = element.dirConfig;
      return [
        new ConfigTreeItem(`Source: ${dir.sourceDirectory}`, vscode.TreeItemCollapsibleState.None),
        new ConfigTreeItem(`Output: ${dir.outputFile}`, vscode.TreeItemCollapsibleState.None),
        new ConfigTreeItem(`Exclusions: ${dir.exclusionPatterns.join(', ')}`, vscode.TreeItemCollapsibleState.None),
        new ConfigTreeItem(`Inclusions: ${dir.inclusionPatterns.join(', ')}`, vscode.TreeItemCollapsibleState.None)
      ];
    }

    return [];
  }
}

class ConfigTreeItem extends vscode.TreeItem {
  constructor(
    public readonly label: string,
    public readonly collapsibleState: vscode.TreeItemCollapsibleState,
    public readonly dirConfig?: {
      sourceDirectory: string;
      outputFile: string;
      exclusionPatterns: string[];
      inclusionPatterns: string[];
    }
  ) {
    super(label, collapsibleState);
  }
}
--- END FILE ---

--- FILE: src/test/extension.test.ts ---
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});

--- END FILE ---

--- FILE: src/fileOperations.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {minimatch} from 'minimatch';
import {CodePackerConfig, DirectoryConfig} from './config';
import {debugLog} from './utils';

export async function packCode(config: CodePackerConfig): Promise<Map<string, string> | null> {
  debugLog('Starting packCode function');
  debugLog('Config:', JSON.stringify(config, null, 2));

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    vscode.window.showErrorMessage('No workspace folder found');
    return null;
  }

  const results = new Map<string, string>();

  for (const dirConfig of config.directories) {
    try {
      const result = await packDirectory(workspaceFolder, dirConfig);
      if (result) {
        results.set(dirConfig.outputFile, result);
      }
    } catch (error) {
      console.error(`Error packing directory ${dirConfig.sourceDirectory}:`, error);
      vscode.window.showErrorMessage(`Failed to pack directory ${dirConfig.sourceDirectory}: ${error}`);
    }
  }

  if (results.size > 0) {
    vscode.window.showInformationMessage(
      `Code packed successfully. ${results.size} file(s) created.`,
      'Open Files'
    ).then(selection => {
      if (selection === 'Open Files') {
        for (const [outputFile] of results) {
          const outputPath = path.join(workspaceFolder.uri.fsPath, outputFile);
          vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(outputPath));
        }
      }
    });
    return results;
  }

  return null;
}

async function packDirectory(
  workspaceFolder: vscode.WorkspaceFolder,
  dirConfig: DirectoryConfig
): Promise<string | null> {
  const sourceDir = path.resolve(workspaceFolder.uri.fsPath, dirConfig.sourceDirectory);
  debugLog('Resolved source directory:', sourceDir);

  const outputPath = path.join(workspaceFolder.uri.fsPath, dirConfig.outputFile);
  debugLog('Output file path:', outputPath);

  // Delete the existing output file if it exists
  if (fs.existsSync(outputPath)) {
    try {
      await fs.promises.unlink(outputPath);
      debugLog(`Existing output file deleted: ${outputPath}`);
    } catch (error) {
      console.error(`Error deleting existing output file: ${error}`);
      vscode.window.showErrorMessage(`Failed to delete existing output file: ${outputPath}`);
      return null;
    }
  }

  let output = '';
  output += "--- START OF HEADER ---\n";
  output += `Generated on: ${new Date().toISOString()}\n`;
  output += "Generated by: VS Code Code Packer Extension\n";
  output += "Purpose: Code packing for analysis or documentation\n";
  output += `Source Directory: ${dirConfig.sourceDirectory}\n`;
  output += "--- END OF HEADER ---\n\n";

  try {
    const recursiveExclusionPatterns = dirConfig.exclusionPatterns.map((pattern: string) => {
      if (pattern.includes('/') || pattern.includes('\\')) {
        return pattern.endsWith('/') || pattern.endsWith('\\') ? `${pattern}**` : `${pattern}/**`;
      } else if (pattern.includes('*')) {
        return `**/${pattern}`;
      } else {
        return `**/${pattern}`;
      }
    });

    const allFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(sourceDir, '**'),
      new vscode.RelativePattern(sourceDir, `{${recursiveExclusionPatterns.join(',')}}`)
    );

    debugLog(`Total files found: ${allFiles.length}`);

    const files = allFiles.filter(file => {
      const relativePath = path.relative(sourceDir, file.fsPath).replace(/\\/g, '/');
      debugLog(`Checking file: ${relativePath}`);

      const shouldInclude = dirConfig.inclusionPatterns.length === 0 ||
        dirConfig.inclusionPatterns.some((pattern: string) => {
          const match = minimatch(relativePath, pattern, {matchBase: true});
          debugLog(`  Inclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
          return match;
        });

      const shouldExclude = recursiveExclusionPatterns.some((pattern: string) => {
        const match = minimatch(relativePath, pattern, {matchBase: true});
        debugLog(`  Exclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
        return match;
      });

      return shouldInclude && !shouldExclude;
    });

    let includedCount = 0;
    let excludedCount = 0;

    for (const file of files) {
      const absoluteFilePath = file.fsPath;
      const relativePath = path.relative(sourceDir, absoluteFilePath).replace(/\\/g, '/');

      try {
        const content = await fs.promises.readFile(absoluteFilePath, 'utf8');
        output += `--- FILE: ${relativePath} ---\n`;
        output += content;
        output += "\n--- END FILE ---\n\n";
        includedCount++;
      } catch (err) {
        console.error(`Error reading file ${absoluteFilePath}:`, err);
        vscode.window.showWarningMessage(`Failed to read file: ${relativePath}`);
        excludedCount++;
      }
    }

    debugLog(`Directory ${dirConfig.sourceDirectory}: Total files: ${files.length}, Included: ${includedCount}, Excluded: ${excludedCount}`);

    await fs.promises.writeFile(outputPath, output, 'utf8');
    debugLog('File written successfully:', outputPath);

    return output;
  } catch (err) {
    console.error('Error packing directory:', err);
    let errorMessage = 'An unknown error occurred while packing code.';
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }
    vscode.window.showErrorMessage(`Failed to pack directory ${dirConfig.sourceDirectory}: ${errorMessage}`);
    return null;
  }
}

--- END FILE ---

--- FILE: src/extension.ts ---
import * as vscode from 'vscode';
import {loadConfig, configureCodePacker} from './config';
import {packCode} from './fileOperations';
import {CodePackerTreeDataProvider} from './uiComponents';
import {debugLog, initializeDebugLogging, updateDebugMode} from './utils';

export function activate(context: vscode.ExtensionContext) {
	initializeDebugLogging();
	debugLog('Activating extension');

	const treeDataProvider = new CodePackerTreeDataProvider();
	vscode.window.createTreeView('codePackerExplorer', {treeDataProvider});

	const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
	statusBarItem.text = "$(package) Pack Code";
	statusBarItem.command = 'extension.packCode';
	statusBarItem.show();
	context.subscriptions.push(statusBarItem);

	context.subscriptions.push(
		vscode.commands.registerCommand('extension.packCode', async () => {
			try {
				const config = await loadConfig();
				if (!config) {
					throw new Error('Failed to load configuration');
				}
				await packCode(config);
				treeDataProvider.refresh();
			} catch (error) {
				vscode.window.showErrorMessage(`Error during code packing: ${error}`);
			}
		})
	);

	context.subscriptions.push(
		vscode.commands.registerCommand('extension.configureCodePacker', async () => {
			try {
				await configureCodePacker();
				treeDataProvider.refresh();
			} catch (error) {
				vscode.window.showErrorMessage(`Error during configuration: ${error}`);
			}
		})
	);

	context.subscriptions.push(
		vscode.workspace.onDidChangeConfiguration(e => {
			if (e.affectsConfiguration('codePacker.debug')) {
				updateDebugMode();
			}
		})
	);

	debugLog('Extension activated');
}

export function deactivate() {}
--- END FILE ---

--- FILE: src/config.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {debugLog, setDebugMode, getSafeProjectName, getDefaultExclusionPatterns, getDefaultInclusionPatterns} from './utils';

export interface DirectoryConfig {
  sourceDirectory: string;
  outputFile: string;
  exclusionPatterns: string[];
  inclusionPatterns: string[];
}

export interface CodePackerConfig {
  directories: DirectoryConfig[];
  debug: boolean;
}

export function loadConfig(): CodePackerConfig | null {
  debugLog('Loading configuration');

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    return null;
  }

  const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'code-packer.json');
  debugLog('Attempting to load config from:', configPath);

  if (fs.existsSync(configPath)) {
    try {
      const configContent = fs.readFileSync(configPath, 'utf8');
      const rawConfig = JSON.parse(configContent);
      
      // Handle backward compatibility with old config format
      if ('sourceDirectory' in rawConfig) {
        // Convert old format to new format
        const config: CodePackerConfig = {
          directories: [{
            sourceDirectory: rawConfig.sourceDirectory,
            outputFile: rawConfig.outputFile,
            exclusionPatterns: rawConfig.exclusionPatterns,
            inclusionPatterns: rawConfig.inclusionPatterns
          }],
          debug: rawConfig.debug || false
        };
        setDebugMode(config.debug);
        debugLog('Converted old config format:', config);
        return config;
      }

      // New format
      setDebugMode(rawConfig.debug || false);
      debugLog('Loaded config:', rawConfig);
      return rawConfig;
    } catch (error) {
      console.error('[Code Packer] Error reading config file:', error);
      return null;
    }
  } else {
    debugLog('No config file found, using default settings');
    const settings = vscode.workspace.getConfiguration('codePacker');
    const safeProjectName = getSafeProjectName(workspaceFolder);
    const config: CodePackerConfig = {
      directories: [{
        sourceDirectory: settings.get('defaultSourceDirectory', '.'),
        outputFile: settings.get('defaultOutputFile', `${safeProjectName}_packed_code.txt`),
        exclusionPatterns: settings.get('defaultExclusionPatterns', getDefaultExclusionPatterns()),
        inclusionPatterns: settings.get('defaultInclusionPatterns', getDefaultInclusionPatterns())
      }],
      debug: false
    };
    setDebugMode(config.debug);
    return config;
  }
}

export async function configureCodePacker(): Promise<CodePackerConfig | null> {
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    vscode.window.showErrorMessage('No workspace folder found. Please open a folder before configuring Code Packer.');
    return null;
  }

  debugLog('Workspace folder:', workspaceFolder.uri.fsPath);
  const currentConfig = loadConfig();
  
  const config: CodePackerConfig = currentConfig || {
    directories: [{
      sourceDirectory: '.',
      outputFile: `${getSafeProjectName(workspaceFolder)}_packed_code.txt`,
      exclusionPatterns: getDefaultExclusionPatterns(),
      inclusionPatterns: getDefaultInclusionPatterns()
    }],
    debug: false
  };

  while (true) {
    const action = await vscode.window.showQuickPick([
      'Add New Directory',
      'Edit Directory',
      'Remove Directory',
      'Toggle Debug Mode',
      'Save Configuration',
      'Cancel'
    ], {
      placeHolder: 'Choose an action'
    });

    if (!action || action === 'Cancel') {
      return null;
    }

    if (action === 'Save Configuration') {
      break;
    }

    if (action === 'Toggle Debug Mode') {
      config.debug = !config.debug;
      continue;
    }

    if (action === 'Add New Directory') {
      const dirConfig = await configureDirectoryConfig();
      if (dirConfig) {
        config.directories.push(dirConfig);
      }
    } else if (action === 'Edit Directory') {
      const dirIndex = await selectDirectory(config.directories);
      if (dirIndex !== undefined) {
        const updatedConfig = await configureDirectoryConfig(config.directories[dirIndex]);
        if (updatedConfig) {
          config.directories[dirIndex] = updatedConfig;
        }
      }
    } else if (action === 'Remove Directory') {
      const dirIndex = await selectDirectory(config.directories);
      if (dirIndex !== undefined) {
        config.directories.splice(dirIndex, 1);
        if (config.directories.length === 0) {
          vscode.window.showWarningMessage('At least one directory configuration is required.');
          config.directories.push({
            sourceDirectory: '.',
            outputFile: `${getSafeProjectName(workspaceFolder)}_packed_code.txt`,
            exclusionPatterns: getDefaultExclusionPatterns(),
            inclusionPatterns: getDefaultInclusionPatterns()
          });
        }
      }
    }
  }

  const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'code-packer.json');
  try {
    fs.mkdirSync(path.dirname(configPath), { recursive: true });
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    debugLog('Config file written successfully');
    vscode.window.showInformationMessage('Code Packer configuration saved successfully.');
  } catch (error) {
    console.error('Error writing config file:', error);
    vscode.window.showErrorMessage(`Failed to save Code Packer configuration: ${error}`);
    return null;
  }

  return config;
}

async function configureDirectoryConfig(existing?: DirectoryConfig): Promise<DirectoryConfig | null> {
  const sourceDirectory = await vscode.window.showInputBox({
    prompt: 'Enter source directory (relative to workspace root)',
    value: existing?.sourceDirectory || '.',
    placeHolder: '.',
    validateInput: input => input.includes('..') ? 'Path cannot contain ".."' : null
  });
  
  if (!sourceDirectory) {return null;}

  const outputFile = await vscode.window.showInputBox({
    prompt: 'Enter output file name',
    value: existing?.outputFile || undefined,
    placeHolder: 'packed_code.txt'
  });
  
  if (!outputFile) {return null;}

  const exclusions = await vscode.window.showInputBox({
    prompt: 'Enter exclusion patterns (comma-separated)',
    value: existing?.exclusionPatterns.join(', ') || getDefaultExclusionPatterns().join(', '),
    placeHolder: getDefaultExclusionPatterns().join(', ')
  });
  
  if (!exclusions) {return null;}

  const inclusions = await vscode.window.showInputBox({
    prompt: 'Enter inclusion patterns (comma-separated)',
    value: existing?.inclusionPatterns.join(', ') || getDefaultInclusionPatterns().join(', '),
    placeHolder: getDefaultInclusionPatterns().join(', ')
  });
  
  if (!inclusions) {return null;}

  return {
    sourceDirectory,
    outputFile,
    exclusionPatterns: exclusions.split(',').map(p => p.trim()).filter(p => p !== ''),
    inclusionPatterns: inclusions.split(',').map(p => p.trim()).filter(p => p !== '')
  };
}

async function selectDirectory(directories: DirectoryConfig[]): Promise<number | undefined> {
  const items = directories.map((dir, index) => ({
    label: `${index + 1}. ${dir.sourceDirectory}`,
    description: `Output: ${dir.outputFile}`,
    index
  }));

  const selected = await vscode.window.showQuickPick(items, {
    placeHolder: 'Select a directory configuration'
  });

  return selected?.index;
}

--- END FILE ---

