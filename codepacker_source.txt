--- START OF HEADER ---
Generated on: 2024-11-06T14:39:57.156Z
Generated by: VS Code Code Packer Extension
Purpose: Code packing for analysis or documentation
--- END OF HEADER ---

--- FILE: CHANGELOG.md ---
# Change Log

All notable changes to the "codepacker" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## 1.0.2

- Fixed issue with recursive named-file exclusion.

## 1.0.1

- Fixed issue with recursive directory exclusion.

## 1.0.0

- Initial release
--- END FILE ---

--- FILE: LICENSE.md ---
# MIT License

Copyright (c) 2024 [Your Name or Organization]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--- END FILE ---

--- FILE: esbuild.js ---
const esbuild = require("esbuild");

const production = process.argv.includes('--production');
const watch = process.argv.includes('--watch');

/**
 * @type {import('esbuild').Plugin}
 */
const esbuildProblemMatcherPlugin = {
	name: 'esbuild-problem-matcher',

	setup(build) {
		build.onStart(() => {
			console.log('[watch] build started');
		});
		build.onEnd((result) => {
			result.errors.forEach(({ text, location }) => {
				console.error(`✘ [ERROR] ${text}`);
				console.error(`    ${location.file}:${location.line}:${location.column}:`);
			});
			console.log('[watch] build finished');
		});
	},
};

async function main() {
	const ctx = await esbuild.context({
		entryPoints: [
			'src/extension.ts'
		],
		bundle: true,
		format: 'cjs',
		minify: production,
		sourcemap: !production,
		sourcesContent: false,
		platform: 'node',
		outfile: 'dist/extension.js',
		external: ['vscode'],
		logLevel: 'silent',
		plugins: [
			/* add to the end of plugins array */
			esbuildProblemMatcherPlugin,
		],
	});
	if (watch) {
		await ctx.watch();
	} else {
		await ctx.rebuild();
		await ctx.dispose();
	}
}

main().catch(e => {
	console.error(e);
	process.exit(1);
});

--- END FILE ---

--- FILE: tsconfig.json ---
{
	"compilerOptions": {
		"module": "Node16",
		"target": "ES2022",
		"outDir": "dist",
		"lib": [
			"ES2022"
		],
		"sourceMap": true,
		"rootDir": "src",
		"strict": true /* enable all strict type-checking options */
		/* Additional Checks */
		// "noImplicitReturns": true, /* Report error when not all code paths in function return a value. */
		// "noFallthroughCasesInSwitch": true, /* Report errors for fallthrough cases in switch statement. */
		// "noUnusedParameters": true,  /* Report errors on unused parameters. */
	},
	"exclude": [
		"node_modules",
		".vscode-test"
	]
}
--- END FILE ---

--- FILE: vsc-extension-quickstart.md ---
# Welcome to your VS Code Extension

## What's in the folder

* This folder contains all of the files necessary for your extension.
* `package.json` - this is the manifest file in which you declare your extension and command.
  * The sample plugin registers a command and defines its title and command name. With this information VS Code can show the command in the command palette. It doesn’t yet need to load the plugin.
* `src/extension.ts` - this is the main file where you will provide the implementation of your command.
  * The file exports one function, `activate`, which is called the very first time your extension is activated (in this case by executing the command). Inside the `activate` function we call `registerCommand`.
  * We pass the function containing the implementation of the command as the second parameter to `registerCommand`.

## Setup

* install the recommended extensions (amodio.tsl-problem-matcher, ms-vscode.extension-test-runner, and dbaeumer.vscode-eslint)


## Get up and running straight away

* Press `F5` to open a new window with your extension loaded.
* Run your command from the command palette by pressing (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and typing `Hello World`.
* Set breakpoints in your code inside `src/extension.ts` to debug your extension.
* Find output from your extension in the debug console.

## Make changes

* You can relaunch the extension from the debug toolbar after changing code in `src/extension.ts`.
* You can also reload (`Ctrl+R` or `Cmd+R` on Mac) the VS Code window with your extension to load your changes.


## Explore the API

* You can open the full set of our API when you open the file `node_modules/@types/vscode/index.d.ts`.

## Run tests

* Install the [Extension Test Runner](https://marketplace.visualstudio.com/items?itemName=ms-vscode.extension-test-runner)
* Run the "watch" task via the **Tasks: Run Task** command. Make sure this is running, or tests might not be discovered.
* Open the Testing view from the activity bar and click the Run Test" button, or use the hotkey `Ctrl/Cmd + ; A`
* See the output of the test result in the Test Results view.
* Make changes to `src/test/extension.test.ts` or create new test files inside the `test` folder.
  * The provided test runner will only consider files matching the name pattern `**.test.ts`.
  * You can create folders inside the `test` folder to structure your tests any way you want.

## Go further

* Reduce the extension size and improve the startup time by [bundling your extension](https://code.visualstudio.com/api/working-with-extensions/bundling-extension).
* [Publish your extension](https://code.visualstudio.com/api/working-with-extensions/publishing-extension) on the VS Code extension marketplace.
* Automate builds by setting up [Continuous Integration](https://code.visualstudio.com/api/working-with-extensions/continuous-integration).

--- END FILE ---

--- FILE: README.md ---
# Code Packer

<p align="center">
  <img src="./images/codepacker-icon.png" alt="Code Packer Logo" width="128"/>
</p>

Code Packer is a Visual Studio Code extension that allows you to easily pack your project's code files into a single text file. This allows you to share a single file with an LLM to give it full context of your project's code, ensuring accurate context of your project at any time.

## Features

- Pack multiple code files into a single text file
- Customizable source directory, output file, and file patterns
- Exclude specific files or directories from packing
- Include only specific file types in the packed output
- Easy-to-use interface with status bar button and explorer view
- Project-specific and global configuration options
- Debug mode for troubleshooting

### Pack Code
Quickly pack your code using the status bar button or command palette.

### Configure Settings
Easily configure your packing settings through the extension's UI.

### Explorer View
View your current Code Packer configuration in the VS Code explorer.

## Requirements

This extension requires Visual Studio Code version 1.90.0 or higher.

## Extension Settings

This extension contributes the following settings:

* `codePacker.debug`: Enable or disable debug mode for Code Packer.
* `codePacker.defaultSourceDirectory`: Set the default source directory for code packing (relative to workspace root).
* `codePacker.defaultOutputFile`: Set the default output file name for packed code.
* `codePacker.defaultExclusionPatterns`: Set default patterns for files to exclude from packing.
* `codePacker.defaultInclusionPatterns`: Set default patterns for files to include in packing.

You can configure these settings globally in your VS Code settings, or per-project in the `.vscode/settings.json` file.

Additionally, you can create a project-specific configuration file `.vscode/code-packer.json` with the following structure:

```json
{
  "sourceDirectory": ".",
  "outputFile": "packed_code.txt",
  "exclusionPatterns": [
    "node_modules",
    "dist",
    "*.vsix",
    "package-lock.json"
  ],
  "inclusionPatterns": [
    "*.ts",
    "*.js",
    "*.json",
    "*.md"
  ],
  "debug": false
}
```

## How to Use

1. Install the Code Packer extension from the VS Code Marketplace.
2. Open a project in VS Code.
3. Click the "Pack Code" button in the status bar or run the "Pack Code" command from the command palette.
4. If it's your first time using the extension in the project, you'll be prompted to configure your settings.
5. The extension will pack your code according to your settings and save it to the specified output file.
6. You can view and modify your current configuration in the Code Packer explorer view.

## Known Issues

Currently, there are no known issues. If you encounter any problems, please report them on our [GitHub issues page](https://github.com/JustinSchneider/CodePacker/issues).

## Release Notes

### 1.0.0

Initial release of Code Packer:
- Basic code packing functionality
- Customizable source directory, output file, and file patterns
- Status bar button for quick access
- Explorer view for configuration display
- Global and project-specific settings

---

## Contributing

If you'd like to contribute to the development of Code Packer, please visit our [GitHub repository](https://github.com/JustinSchneider/CodePacker).

## License

This extension is licensed under the [MIT License](LICENSE.md).
--- END FILE ---

--- FILE: package.json ---
{
  "name": "codepacker",
  "displayName": "Code Packer",
  "description": "Pack project code files into a text file for easy sharing with LLMs",
  "version": "1.0.2",
  "icon": "images/codepacker-icon.png",
  "publisher": "JustinSchneider",
  "engines": {
    "vscode": "^1.90.0"
  },
  "categories": [
    "Other"
  ],
  "activationEvents": [],
  "main": "./dist/extension.js",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/JustinSchneider/CodePacker.git"
  },
  "contributes": {
    "commands": [
      {
        "command": "extension.packCode",
        "title": "Pack Code"
      },
      {
        "command": "extension.configureCodePacker",
        "title": "Configure Code Packer"
      }
    ],
    "views": {
      "explorer": [
        {
          "id": "codePackerExplorer",
          "name": "Code Packer"
        }
      ]
    },
    "configuration": {
      "title": "Code Packer",
      "properties": {
        "codePacker.debug": {
          "type": "boolean",
          "default": false,
          "description": "Enable debug mode for Code Packer"
        },
        "codePacker.defaultSourceDirectory": {
          "type": "string",
          "default": ".",
          "description": "Default source directory for code packing"
        },
        "codePacker.defaultOutputFile": {
          "type": "string",
          "default": "packed_code.txt",
          "description": "Default output file name for packed code"
        },
        "codePacker.defaultExclusionPatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            "node_modules",
            "package-lock.json",
            ".git",
            "build",
            "dist",
            "out",
            "*.log",
            "*.lock",
            ".vscode"
          ],
          "description": "Default patterns for files to exclude from packing"
        },
        "codePacker.defaultInclusionPatterns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "default": [
            "*.cs",
            "*.ts",
            "*.js",
            "*.json",
            "*.md",
            "*.html",
            "*.css",
            "*.scss"
          ],
          "description": "Default patterns for files to include in packing"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run package",
    "compile": "npm run check-types && npm run lint && node esbuild.js",
    "watch": "npm-run-all -p watch:*",
    "watch:esbuild": "node esbuild.js --watch",
    "watch:tsc": "tsc --noEmit --watch --project tsconfig.json",
    "prelaunch": "npm run compile",
    "package": "npm run check-types && npm run lint && node esbuild.js --production",
    "compile-tests": "tsc -p . --outDir out",
    "watch-tests": "tsc -p . -w --outDir out",
    "pretest": "npm run compile-tests && npm run compile && npm run lint",
    "check-types": "tsc --noEmit",
    "lint": "eslint src --ext ts",
    "test": "vscode-test"
  },
  "devDependencies": {
    "@types/minimatch": "^5.1.2",
    "@types/mocha": "^10.0.7",
    "@types/node": "^20.14.9",
    "@types/vscode": "^1.90.0",
    "@typescript-eslint/eslint-plugin": "^7.14.1",
    "@typescript-eslint/parser": "^7.11.0",
    "@vscode/test-cli": "^0.0.9",
    "@vscode/test-electron": "^2.4.0",
    "esbuild": "^0.21.5",
    "eslint": "^8.57.0",
    "npm-run-all": "^4.1.5",
    "typescript": "^5.4.5"
  },
  "dependencies": {
    "minimatch": "^9.0.5"
  }
}
--- END FILE ---

--- FILE: .vscode/tasks.json ---
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "watch",
            "dependsOn": [
                "npm: watch:tsc",
                "npm: watch:esbuild"
            ],
            "presentation": {
                "reveal": "never"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "type": "npm",
            "script": "watch:esbuild",
            "group": "build",
            "problemMatcher": [
                {
                    "owner": "esbuild",
                    "pattern": [
                        {
                            "regexp": "^✘\\s+\\[ERROR\\]\\s+(.*)$",
                            "message": 1
                        },
                        {
                            "regexp": "^\\s+(.*):(\\d+):(\\d+):$",
                            "file": 1,
                            "line": 2,
                            "column": 3
                        }
                    ],
                    "background": {
                        "activeOnStart": true,
                        "beginsPattern": "^\\[watch\\] build started",
                        "endsPattern": "^\\[watch\\] build finished"
                    }
                }
            ],
            "isBackground": true,
            "label": "npm: watch:esbuild",
            "presentation": {
                "group": "watch",
                "reveal": "never"
            }
        },
        {
            "type": "npm",
            "script": "watch:tsc",
            "group": "build",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "label": "npm: watch:tsc",
            "presentation": {
                "group": "watch",
                "reveal": "never"
            }
        },
        {
            "type": "npm",
            "script": "watch-tests",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "presentation": {
                "reveal": "never",
                "group": "watchers"
            },
            "group": "build"
        },
        {
            "label": "tasks: watch-tests",
            "dependsOn": [
                "npm: watch",
                "npm: watch-tests"
            ],
            "problemMatcher": []
        }
    ]
}
--- END FILE ---

--- FILE: .vscode/settings.json ---
// Place your settings in this file to overwrite default and user settings.
{
    "files.exclude": {
        "out": false, // set this to true to hide the "out" folder with the compiled JS files
        "dist": false // set this to true to hide the "dist" folder with the compiled JS files
    },
    "search.exclude": {
        "out": true, // set this to false to include "out" folder in search results
        "dist": true // set this to false to include "dist" folder in search results
    },
    // Turn off tsc task auto detection since we have the necessary tasks as npm scripts
    "typescript.tsc.autoDetect": "off"
}
--- END FILE ---

--- FILE: .vscode/launch.json ---
// A launch configuration that compiles the extension and then opens it inside a new window
// Use IntelliSense to learn about possible attributes.
// Hover to view descriptions of existing attributes.
// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
{
	"version": "0.2.0",
	"configurations": [
		{
			"name": "Run Extension",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}"
			],
			"outFiles": [
				"${workspaceFolder}/dist/**/*.js"
			],
			"preLaunchTask": "npm: watch"
		},
		{
			"name": "Extension Tests",
			"type": "extensionHost",
			"request": "launch",
			"args": [
				"--extensionDevelopmentPath=${workspaceFolder}",
				"--extensionTestsPath=${workspaceFolder}/out/test/suite/index"
			],
			"outFiles": [
				"${workspaceFolder}/out/**/*.js"
			],
			"preLaunchTask": "npm: pretest"
		}
	],
	"compounds": [
		{
			"name": "Watch and Run Extension",
			"configurations": [
				"Run Extension"
			],
			"preLaunchTask": "npm: watch"
		}
	]
}
--- END FILE ---

--- FILE: .vscode/extensions.json ---
{
  // See http://go.microsoft.com/fwlink/?LinkId=827846
  // for the documentation about the extensions.json format
  "recommendations": ["dbaeumer.vscode-eslint", "connor4312.esbuild-problem-matchers", "ms-vscode.extension-test-runner"]
}

--- END FILE ---

--- FILE: .vscode/code-packer.json ---
{
  "sourceDirectory": ".",
  "outputFile": "codepacker_source.txt",
  "exclusionPatterns": [
    "node_modules",
    "dist",
    "images",
    "*.vsix",
    "package-lock.json"
  ],
  "inclusionPatterns": [
    "*.ts",
    "*.md",
    "*.json",
    "*.js"
  ],
  "debug": true
}
--- END FILE ---

--- FILE: src/config.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {debugLog, setDebugMode, getSafeProjectName, getDefaultExclusionPatterns, getDefaultInclusionPatterns} from './utils';

export interface CodePackerConfig {
  sourceDirectory: string;
  outputFile: string;
  exclusionPatterns: string[];
  inclusionPatterns: string[];
  debug: boolean;
}

export function loadConfig(): CodePackerConfig | null {
  debugLog('Loading configuration');

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    return null;
  }

  const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'code-packer.json');
  debugLog('Attempting to load config from:', configPath);

  if (fs.existsSync(configPath)) {
    try {
      const configContent = fs.readFileSync(configPath, 'utf8');
      const config = JSON.parse(configContent);
      setDebugMode(config.debug || false);  // Set debug mode
      debugLog('Loaded config:', config);
      return config;
    } catch (error) {
      console.error('[Code Packer] Error reading config file:', error);
      return null;
    }
  } else {
    debugLog('No config file found, using default settings');
    const settings = vscode.workspace.getConfiguration('codePacker');
    const safeProjectName = getSafeProjectName(workspaceFolder);
    const config = {
      sourceDirectory: settings.get('defaultSourceDirectory', '.'),
      outputFile: settings.get('defaultOutputFile', `${safeProjectName}_packed_code.txt`),
      exclusionPatterns: settings.get('defaultExclusionPatterns', getDefaultExclusionPatterns()),
      inclusionPatterns: settings.get('defaultInclusionPatterns', getDefaultInclusionPatterns()),
      debug: false  // Default to false for default settings
    };
    setDebugMode(config.debug);  // Set debug mode
    return config;
  }
}

export async function configureCodePacker(): Promise<CodePackerConfig | null> {
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    vscode.window.showErrorMessage('No workspace folder found. Please open a folder before configuring Code Packer.');
    return null;
  }

  debugLog('Workspace folder:', workspaceFolder.uri.fsPath);

  const safeProjectName = getSafeProjectName(workspaceFolder);
  const defaultConfig = {
    sourceDirectory: '.',
    outputFile: `${safeProjectName}_packed_code.txt`,
    exclusionPatterns: getDefaultExclusionPatterns(),
    inclusionPatterns: getDefaultInclusionPatterns(),
    debug: false
  };

  let config = loadConfig() || defaultConfig;
  debugLog('Loaded or default config:', config);

  config.sourceDirectory = await vscode.window.showInputBox({
    prompt: 'Enter source directory (relative to workspace root)',
    value: config.sourceDirectory,
    placeHolder: '.',
    validateInput: input => input.includes('..') ? 'Path cannot contain ".."' : null
  }) || config.sourceDirectory;

  config.outputFile = await vscode.window.showInputBox({
    prompt: 'Enter output file name',
    value: config.outputFile,
    placeHolder: `${safeProjectName}_packed_code.txt`
  }) || config.outputFile;

  const exclusions = await vscode.window.showInputBox({
    prompt: 'Enter exclusion patterns (comma-separated)',
    value: config.exclusionPatterns.join(', '),
    placeHolder: getDefaultExclusionPatterns().join(', ')
  });
  if (exclusions !== undefined) {
    config.exclusionPatterns = exclusions.split(',').map(p => p.trim()).filter(p => p !== '');
  }

  const inclusions = await vscode.window.showInputBox({
    prompt: 'Enter inclusion patterns (comma-separated)',
    value: config.inclusionPatterns.join(', '),
    placeHolder: getDefaultInclusionPatterns().join(', ')
  });
  if (inclusions !== undefined) {
    config.inclusionPatterns = inclusions.split(',').map(p => p.trim()).filter(p => p !== '');
  }

  debugLog('Updated config:', config);

  const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'code-packer.json');
  debugLog('Config file path:', configPath);

  try {
    fs.mkdirSync(path.dirname(configPath), {recursive: true});
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    debugLog('Config file written successfully');
    vscode.window.showInformationMessage('Code Packer configuration saved successfully.');
  } catch (error) {
    console.error('Error writing config file:', error);
    vscode.window.showErrorMessage(`Failed to save Code Packer configuration: ${error}`);
    return null;
  }

  return config;
}
--- END FILE ---

--- FILE: src/extension.ts ---
import * as vscode from 'vscode';
import {loadConfig, configureCodePacker} from './config';
import {packCode} from './fileOperations';
import {CodePackerTreeDataProvider} from './uiComponents';
import {debugLog, initializeDebugLogging, updateDebugMode} from './utils';

export function activate(context: vscode.ExtensionContext) {
	initializeDebugLogging();
	debugLog('Activating extension');

	const treeDataProvider = new CodePackerTreeDataProvider();
	vscode.window.createTreeView('codePackerExplorer', {treeDataProvider});

	const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
	statusBarItem.text = "$(package) Pack Code";
	statusBarItem.command = 'extension.packCode';
	statusBarItem.show();
	context.subscriptions.push(statusBarItem);

	context.subscriptions.push(
		vscode.commands.registerCommand('extension.packCode', async () => {
			try {
				const config = await loadConfig();
				if (!config) {
					throw new Error('Failed to load configuration');
				}
				await packCode(config);
				treeDataProvider.refresh();
			} catch (error) {
				vscode.window.showErrorMessage(`Error during code packing: ${error}`);
			}
		})
	);

	context.subscriptions.push(
		vscode.commands.registerCommand('extension.configureCodePacker', async () => {
			try {
				await configureCodePacker();
				treeDataProvider.refresh();
			} catch (error) {
				vscode.window.showErrorMessage(`Error during configuration: ${error}`);
			}
		})
	);

	context.subscriptions.push(
		vscode.workspace.onDidChangeConfiguration(e => {
			if (e.affectsConfiguration('codePacker.debug')) {
				updateDebugMode();
			}
		})
	);

	debugLog('Extension activated');
}

export function deactivate() {}
--- END FILE ---

--- FILE: src/fileOperations.ts ---
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import {minimatch} from 'minimatch';
import {CodePackerConfig} from './config';
import {debugLog} from './utils';

export async function packCode(config: CodePackerConfig): Promise<string | null> {
  debugLog('Starting packCode function');
  debugLog('Config:', JSON.stringify(config, null, 2));

  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    console.error('No workspace folder found');
    vscode.window.showErrorMessage('No workspace folder found');
    return null;
  }
  debugLog('Workspace folder:', workspaceFolder.uri.fsPath);

  const sourceDir = path.resolve(workspaceFolder.uri.fsPath, config.sourceDirectory);
  debugLog('Resolved source directory:', sourceDir);

  const outputPath = path.join(workspaceFolder.uri.fsPath, config.outputFile);
  debugLog('Output file path:', outputPath);

  // Delete the existing output file if it exists
  if (fs.existsSync(outputPath)) {
    try {
      await fs.promises.unlink(outputPath);
      debugLog(`Existing output file deleted: ${outputPath}`);
    } catch (error) {
      console.error(`Error deleting existing output file: ${error}`);
      vscode.window.showErrorMessage(`Failed to delete existing output file: ${outputPath}`);
      return null;
    }
  }

  let output = '';

  output += "--- START OF HEADER ---\n";
  output += `Generated on: ${new Date().toISOString()}\n`;
  output += "Generated by: VS Code Code Packer Extension\n";
  output += "Purpose: Code packing for analysis or documentation\n";
  output += "--- END OF HEADER ---\n\n";

  try {
    debugLog('Starting file search');
    debugLog('Source directory:', sourceDir);
    debugLog('Exclusion patterns:', config.exclusionPatterns);
    debugLog('Inclusion patterns:', config.inclusionPatterns);

    const recursiveExclusionPatterns = config.exclusionPatterns.map(pattern => {
      if (pattern.includes('/') || pattern.includes('\\')) {
        // It's a path, make it recursive
        return pattern.endsWith('/') || pattern.endsWith('\\') ? `${pattern}**` : `${pattern}/**`;
      } else if (pattern.includes('*')) {
        // It's already a glob pattern, make it match in all directories
        return `**/${pattern}`;
      } else {
        // It's a specific filename, make it match in all directories
        return `**/${pattern}`;
      }
    });

    // Use '**' to recursively search all directories and files
    const allFiles = await vscode.workspace.findFiles(
      new vscode.RelativePattern(sourceDir, '**'),
      new vscode.RelativePattern(sourceDir, `{${recursiveExclusionPatterns.join(',')}}`)
    );

    debugLog(`Total files found: ${allFiles.length}`);
    allFiles.forEach(file => debugLog(`Found file: ${file.fsPath}`));

    const files = allFiles.filter(file => {
      const relativePath = path.relative(sourceDir, file.fsPath).replace(/\\/g, '/');
      debugLog(`Checking file: ${relativePath}`);

      const shouldInclude = config.inclusionPatterns.length === 0 ||
        config.inclusionPatterns.some(pattern => {
          const match = minimatch(relativePath, pattern, {matchBase: true});
          debugLog(`  Inclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
          return match;
        });

      const shouldExclude = recursiveExclusionPatterns.some(pattern => {
        const match = minimatch(relativePath, pattern, {matchBase: true});
        debugLog(`  Exclusion pattern ${pattern}: ${match ? 'matched' : 'not matched'}`);
        return match;
      });

      if (shouldInclude && !shouldExclude) {
        debugLog(`Including file: ${relativePath}`);
        return true;
      } else {
        debugLog(`Excluding file: ${relativePath}`);
        return false;
      }
    });

    debugLog(`Files after applying patterns: ${files.length}`);

    let includedCount = 0;
    let excludedCount = 0;

    for (const file of files) {
      const absoluteFilePath = file.fsPath;
      const relativePath = path.relative(sourceDir, absoluteFilePath).replace(/\\/g, '/');

      debugLog(`Processing file: ${relativePath}`);

      try {
        const content = await fs.promises.readFile(absoluteFilePath, 'utf8');
        output += `--- FILE: ${relativePath} ---\n`;
        output += content;
        output += "\n--- END FILE ---\n\n";
        includedCount++;
      } catch (err) {
        console.error(`Error reading file ${absoluteFilePath}:`, err);
        vscode.window.showWarningMessage(`Failed to read file: ${relativePath}`);
        excludedCount++;
      }
    }

    debugLog(`Total files: ${files.length}, Included: ${includedCount}, Excluded: ${excludedCount}`);

    // Write the output to file
    debugLog('Writing output to file:', outputPath);
    await fs.promises.writeFile(outputPath, output, 'utf8');
    debugLog('File written successfully');

    // Show a success message
    vscode.window.showInformationMessage(`Code packed successfully. Output file: ${outputPath}`, 'Open File')
      .then(selection => {
        if (selection === 'Open File') {
          vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(outputPath));
        }
      });

  } catch (err) {
    console.error('Error packing code:', err);
    let errorMessage = 'An unknown error occurred while packing code.';
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }
    vscode.window.showErrorMessage(`Failed to pack code: ${errorMessage}`);
    return null;
  }

  debugLog('Packing completed successfully');
  return output;
}
--- END FILE ---

--- FILE: src/utils.ts ---
import * as vscode from 'vscode';
import * as path from 'path';

let outputChannel: vscode.OutputChannel;
let isDebugMode = false;

export function initializeDebugLogging() {
  outputChannel = vscode.window.createOutputChannel('Code Packer');
  updateDebugMode();
}

export function updateDebugMode() {
  const config = vscode.workspace.getConfiguration('codePacker');
  isDebugMode = config.get<boolean>('debug', false);
  debugLog(`Debug mode ${isDebugMode ? 'enabled' : 'disabled'}`);
}

export function setDebugMode(debug: boolean) {
  isDebugMode = debug;
}

export function debugLog(...args: any[]) {
  if (isDebugMode) {
    const message = args.map(arg =>
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
    ).join(' ');

    if (outputChannel) {
      outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
    }
    console.log(`[Code Packer Debug] ${message}`);
  }
}

export function getSafeProjectName(workspaceFolder: vscode.WorkspaceFolder): string {
  const projectName = path.basename(workspaceFolder.uri.fsPath);
  return projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

export function getDefaultExclusionPatterns(): string[] {
  return [
    'node_modules',
    '.git',
    'build',
    'dist',
    'out',
    '*.log',
    '*.lock',
    '*.vsix',
    '.vscode'
  ];
}

export function getDefaultInclusionPatterns(): string[] {
  return [
    '*.ts',
    '*.js',
    '*.json',
    '*.md',
    '*.txt',
    '*.html',
    '*.css',
    '*.scss'
  ];
}
--- END FILE ---

--- FILE: src/uiComponents.ts ---
import * as vscode from 'vscode';
import {loadConfig} from './config';

export class CodePackerTreeDataProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null | void> = new vscode.EventEmitter<vscode.TreeItem | undefined | null | void>();
  readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
    return element;
  }

  getChildren(element?: vscode.TreeItem): Thenable<vscode.TreeItem[]> {
    if (!element) {
      const config = loadConfig();
      if (!config) {return Promise.resolve([]);}

      return Promise.resolve([
        new vscode.TreeItem(`Source: ${config.sourceDirectory}`),
        new vscode.TreeItem(`Output: ${config.outputFile}`),
        new vscode.TreeItem(`Exclusions: ${config.exclusionPatterns.join(', ')}`),
        new vscode.TreeItem(`Inclusions: ${config.inclusionPatterns.join(', ')}`),
      ]);
    }
    return Promise.resolve([]);
  }
}
--- END FILE ---

--- FILE: src/test/extension.test.ts ---
import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});

--- END FILE ---

